#!/usr/bin/env bash

git commit -m "TEMP" --no-verify    # Makes a temp commit of all staged changes (skipping hooks, obviously)

# Check if we have anything left, including untracked files. If there are, rig up a trap to stash them at the end.
# If not, don't have any meaningful trap (no-op). This is needed because there is no nice programmatic way to
# distinguish between "stash made" and "stash not made because there are no changes."
if [ -z "$(git status --porcelain=v1 2>/dev/null)" ]
then
  function undo_setup()
  {
    # nothing to stash, nothing to pop; leaving this no-op in here to make bash happy
    true
  }
else
  function undo_setup()
  {
    git restore . > /dev/null     # Drops any changes made by the commit hook; this should only be relevant if the hook failed
    git stash pop > /dev/null     # Gives back the unstaged / untracked changes
  }
fi
trap undo_setup EXIT # this will trigger if the script errors OR has a happy exit

git stash -u                        # Stashes every change (which is just anything that was unstaged or untracked before)
git reset --soft HEAD^              # Deletes the TEMP commit and rolls back to the pre-commited state, so everything is still added

set -e

echo "== Running pre-commit scripts ==="

echo "Running code formatter (workspace)"
cargo +nightly fmt --all

echo "Running code linter (does not block commit, but should be addressed before push)"
cargo clippy --workspace --tests || true

if [ -n "$(git ls-files --modified)" ]; then
  git ls-files --modified | xargs -n 1 git add
fi
